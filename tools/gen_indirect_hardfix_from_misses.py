#!/usr/bin/env python3
import argparse
from pathlib import Path
import re
from bisect import bisect_left

def parse_misses_file(path: Path) -> list[int]:
    if not path.exists():
        return []
    addrs = []
    for line in path.read_text(encoding='utf-8', errors='ignore').splitlines():
        line = line.strip()
        if not line:
            continue
        if line.startswith('#'):
            continue
        try:
            addrs.append(int(line, 16))
        except ValueError:
            pass
    return sorted(set(addrs))

def parse_html_functions(html_path: Path) -> list[int]:
    rx_anchor = re.compile(r'(?:id|name)\s*=\s*["\']sub_([0-9A-Fa-f]{6,8})["\']')
    rx_label  = re.compile(r">\s*sub_([0-9A-Fa-f]{6,8})\s*[:( ]")
    addrs = set()
    with html_path.open('r', encoding='utf-8', errors='ignore') as f:
        for line in f:
            for m in rx_anchor.finditer(line):
                addrs.add(int(m.group(1), 16))
            for m in rx_label.finditer(line):
                addrs.add(int(m.group(1), 16))
    return sorted(addrs)

def emit_cpp(redirects: dict[int,int]) -> str:
    lines = []
    lines.append('// Auto-generated by tools/gen_indirect_hardfix_from_misses.py; DO NOT EDIT')
    lines.append('#include <kernel/memory.h>')
    lines.append('#include <cpu/ppc_context.h>')
    lines.append('')
    for tgt in sorted(set(redirects.values())):
        lines.append(f'void sub_{tgt:08X}(PPCContext& __restrict, uint8_t*);')
    lines.append('')
    lines.append('static void RegisterIndirectHardfixesGen() {')
    for miss, tgt in sorted(redirects.items()):
        lines.append(f'    g_memory.InsertFunction(0x{miss:08X}, sub_{tgt:08X});')
    lines.append('}')
    lines.append('')
    lines.append('#if defined(_MSC_VER)')
    lines.append('#  pragma section(".CRT$XCU",read)')
    lines.append('    static void __cdecl ppc_indirect_hardfix_gen_ctor();')
    lines.append('    __declspec(allocate(".CRT$XCU")) void (*ppc_indirect_hardfix_gen_ctor_)(void) = ppc_indirect_hardfix_gen_ctor;')
    lines.append('    static void __cdecl ppc_indirect_hardfix_gen_ctor() { RegisterIndirectHardfixesGen(); }')
    lines.append('#else')
    lines.append('    __attribute__((constructor)) static void ppc_indirect_hardfix_gen_ctor() { RegisterIndirectHardfixesGen(); }')
    lines.append('#endif')
    lines.append('')
    return "\n".join(lines) + "\n"

def main():
    ap = argparse.ArgumentParser(description='Generate hardfix redirects from extracted misses')
    ap.add_argument('--misses', type=Path, required=True)
    ap.add_argument('--html', type=Path, required=True)
    ap.add_argument('--out-cpp', type=Path, required=True)
    args = ap.parse_args()

    misses = parse_misses_file(args.misses)
    if not misses:
        # still produce a TU to keep build stable
        args.out_cpp.parent.mkdir(parents=True, exist_ok=True)
        args.out_cpp.write_text('// no misses found\n', encoding='utf-8')
        print(f'[gen_indirect_hardfix] 0 misses -> {args.out_cpp}')
        return 0

    starts = parse_html_functions(args.html)
    redirects: dict[int,int] = {}
    for m in misses:
        i = bisect_left(starts, m)
        if i < len(starts):
            redirects[m] = starts[i]
    args.out_cpp.parent.mkdir(parents=True, exist_ok=True)
    args.out_cpp.write_text(emit_cpp(redirects), encoding='utf-8')
    print(f'[gen_indirect_hardfix] {len(redirects)} redirects -> {args.out_cpp}')
    return 0

if __name__ == '__main__':
    raise SystemExit(main())

