# Handoff to Next Agent - MW05 Recompilation Project

## üéØ What Was Accomplished

### ‚úÖ Major Success: PPC Recompiler Bug Fixed!

I successfully identified and fixed a critical bug in the PowerPC-to-x64 recompiler that was preventing proper 64-bit arithmetic operations.

**The Bug**:
- `divw` (divide word) instruction only wrote to lower 32 bits of register
- Upper 32 bits were left undefined on little-endian x64 systems
- PowerPC 64-bit architecture requires sign-extension to 64 bits

**The Fix**:
- File: `tools/XenonRecomp/XenonRecomp/recompiler.cpp` lines 913-925
- Changed from: `ctx.r9.s32 = ctx.r10.s32 / ctx.r30.s32;`
- Changed to: `ctx.r9.s64 = int64_t(ctx.r10.s32) / int64_t(ctx.r30.s32);`
- Also fixed `divwu` (unsigned division) to zero-extend

**Verification**:
```
Division:  -10000000 / 100 = -100000 (0xFFFE7960) ‚úÖ
Sign-ext:  0xFFFE7960 ‚Üí 0xFFFFFFFFFFFE7960 ‚úÖ
Store:     Value stored to 0x828F1F98 ‚úÖ
```

### ‚ö†Ô∏è New Problem Discovered: Memory Corruption

Even though the recompiler fix works perfectly, the value at `qword_828F1F98` is being overwritten to 0 after it's stored but before the function returns.

**Evidence**:
```
[STD-DEBUG] AFTER std: stored to 0x828F1F98
[WORKER-INIT] AFTER: qword_828F1F98 = 0x0000000000000000  ‚Üê Overwritten!
```

## üö® CRITICAL: What You Need to Do Next

### Task 1: Find What's Overwriting Memory (HIGHEST PRIORITY)

**The Problem**:
- Function `sub_82813598` correctly stores `0xFFFFFFFFFFFE7960` to address `0x828F1F98`
- But when we read it back after the function returns, it's 0
- Something is overwriting the memory between the store and the return

**Where to Look**:

1. **Check sub_82813418** (Thread #2 creation):
   - This function is called immediately after the store
   - It might initialize memory or reset state
   - Search for it in: `Mw05RecompLib/ppc/ppc_recomp.*.cpp`

2. **Check sub_8284E658** (called after thread creation):
   - This function is called after sub_82813418
   - It might also reset state
   - Search for it in: `Mw05RecompLib/ppc/ppc_recomp.*.cpp`

3. **Verify PPC_STORE_U64**:
   - Check the implementation of this macro
   - Ensure byte-swapping is correct
   - Ensure it's actually writing to memory

4. **Add memory watchpoint**:
   - Implement logging for all writes to 0x828F1F98
   - This will show exactly what's overwriting it

**How to Debug**:

```cpp
// Add this to Mw05Recomp/cpu/mw05_trace_threads.cpp or similar
// Monitor all writes to 0x828F1F98
void CheckMemoryCorruption() {
    const uint32_t addr = 0x828F1F98;
    void* host = g_memory.Translate(addr);
    if (host) {
        uint64_t* ptr = (uint64_t*)host;
        uint64_t value = __builtin_bswap64(*ptr);
        fprintf(stderr, "[MEM-WATCH] 0x828F1F98 = 0x%016llX\n", value);
    }
}
```

### Task 2: Implement Permanent Fix

Once you find what's overwriting the memory, you have options:

**Option A: Fix the Root Cause**
- Modify the function that's corrupting memory
- Prevent it from writing to 0x828F1F98

**Option B: Protect the Memory**
- Add logic to prevent overwrites
- Restore the value after corruption

**Option C: Change Storage Location**
- Store the flag in a different memory location
- Update all references to use new location

**Current Workaround** (already in place):
- File: `Mw05Recomp/cpu/mw05_trace_threads.cpp`
- Function: `sub_82813598` wrapper
- Manually sets the flag after function returns
- This is temporary - need permanent fix

### Task 3: Verify Thread #2 Runs Correctly

After fixing the memory corruption:

1. Build and run the game
2. Check logs for Thread #2 activity
3. Verify worker loop is running (not exiting immediately)

**Expected Success**:
```
[WORKER-INIT] SUCCESS: qword_828F1F98 is set to non-zero value!
[GUEST_THREAD] Thread tid=XXXXX entry=82812ED0 RUNNING
```

**Current Failure**:
```
[WORKER-INIT] ERROR: qword_828F1F98 is still 0!
[GUEST_THREAD] Thread tid=XXXXX entry=82812ED0 COMPLETED  ‚Üê Exits immediately
```

## üìö Key Files and Documentation

### Documentation Files (READ THESE FIRST!)

1. **AGENTS.md** - Current debugging status and findings
2. **RECOMPILER_FIX_SUMMARY.md** - Complete summary of recompiler fix
3. **RECOMPILER_BUG_INVESTIGATION.md** - Investigation guide
4. **PROGRESS_REPORT.md** - Updated with current status and next steps

### Source Files

1. **tools/XenonRecomp/XenonRecomp/recompiler.cpp** (lines 913-925)
   - Recompiler source with the fix

2. **Mw05Recomp/cpu/mw05_trace_threads.cpp** (lines 511-577)
   - Thread wrappers with workaround for memory corruption

3. **Mw05RecompLib/ppc/ppc_recomp.96.cpp** (lines 11044-11168)
   - Generated code for sub_82813598
   - **DO NOT EDIT THIS FILE!** It's auto-generated
   - If you need to debug, add logging to the recompiler, not here

### Assembly Reference

From `NfsMWEurope.xex.html`:
```assembly
.text:82813598 sub_82813598:  # Worker thread initialization
.text:828135A8   mr r30, r3   # Save parameter to r30
.text:82813604   bl sub_8284E6C0  # Create event
.text:8281361C   divw r9, r10, r30  # Division (FIXED!)
.text:82813624   extsw r11, r9  # Sign-extend (WORKING!)
.text:8281363C   std r11, 8(r31)  # Store to qword_828F1F98 (WORKING!)
.text:82813640   bl sub_82813418  # Create Thread #2 (SUSPECT!)
.text:82813664   bl sub_8284E658  # Called after thread creation (SUSPECT!)
```

## üõ†Ô∏è Build and Test Commands

### Clean and Rebuild
```powershell
# Clean generated PPC code
./build_cmd.ps1 -Clean -Stage codegen

# Regenerate PPC code (with recompiler fix)
./build_cmd.ps1 -Stage codegen

# Build application
./build_cmd.ps1 -Stage app
```

### Run and Test
```powershell
# Run game and capture output
out/build/x64-Clang-Debug/Mw05Recomp/Mw05Recomp.exe 2> test_output.txt

# Check for success/failure
Get-Content test_output.txt | Select-String 'WORKER-INIT'
```

### Debug Logging
```powershell
# Enable detailed logging
$env:MW05_TRACE_KERNEL = "1"

# Run with timeout
cmd /c "timeout /t 15 /nobreak & taskkill /F /IM Mw05Recomp.exe 2>nul"
out/build/x64-Clang-Debug/Mw05Recomp/Mw05Recomp.exe 2> debug.txt
```

## ‚ö†Ô∏è Important Warnings

### DO NOT Edit Generated PPC Code!
- Files in `Mw05RecompLib/ppc/ppc_recomp.*.cpp` are AUTO-GENERATED
- Any edits will be lost when code is regenerated
- Always fix the recompiler, not the generated code

### DO Clean Before Testing Recompiler Changes
- After modifying `tools/XenonRecomp/XenonRecomp/recompiler.cpp`
- Always run: `./build_cmd.ps1 -Clean -Stage codegen`
- This ensures generated code uses the new recompiler

### DO Check AGENTS.md for Latest Status
- This file is updated with latest findings
- Contains detailed debugging information
- Shows current blockers and next steps

## üéØ Success Criteria

You'll know you've succeeded when:

1. ‚úÖ Memory at 0x828F1F98 remains `0xFFFFFFFFFFFE7960` after function returns
2. ‚úÖ Thread #2 runs its worker loop instead of exiting immediately
3. ‚úÖ Game progresses past Thread #2 initialization
4. ‚úÖ No workarounds needed - root cause is fixed

## üí° Tips and Hints

1. **Use grep to find functions**:
   ```powershell
   Get-ChildItem Mw05RecompLib/ppc/*.cpp | Select-String 'sub_82813418'
   ```

2. **Check memory in debugger**:
   - Address: 0x828F1F98
   - Expected: 0xFFFFFFFFFFFE7960 (big-endian in memory)
   - Actual: 0x0000000000000000

3. **Compare with Xenia**:
   - File: `tools/xenia.log`
   - Shows how Xenia handles this function
   - Can help identify differences

4. **Ask for help if stuck**:
   - Check RECOMPILER_BUG_INVESTIGATION.md for debugging guide
   - Review RECOMPILER_FIX_SUMMARY.md for context
   - Update AGENTS.md with your findings

## üöÄ Good Luck!

The recompiler fix is a major achievement - it will benefit the entire project. Now we just need to solve this memory corruption issue and Thread #2 will run correctly!

Remember:
- The recompiler IS working correctly
- The division, sign-extension, and store all work
- Something is overwriting the memory AFTER the store
- Find that something and fix it!

You've got this! üí™

