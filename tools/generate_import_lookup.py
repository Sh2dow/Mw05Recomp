#!/usr/bin/env python3
"""
Generate import lookup table from imports.cpp

This script parses imports.cpp to find all GUEST_FUNCTION_HOOK declarations
and generates the import_lookup.cpp file with all the necessary declarations
and lookup table entries.
"""

import re
import sys
from pathlib import Path

def extract_imports(imports_cpp_path):
    """Extract all __imp__ function names from imports.cpp"""
    imports = []
    
    with open(imports_cpp_path, 'r', encoding='utf-8') as f:
        content = f.read()
    
    # Find all GUEST_FUNCTION_HOOK(__imp__FunctionName, ...)
    pattern = r'GUEST_FUNCTION_HOOK\(__imp__([A-Za-z0-9_]+)'
    matches = re.findall(pattern, content)
    
    # Remove duplicates and sort
    imports = sorted(set(matches))
    
    return imports

def generate_lookup_cpp(imports, output_path):
    """Generate the import_lookup.cpp file"""
    
    header = """// Auto-generated import function lookup table
// Generated by tools/generate_import_lookup.py
// DO NOT EDIT MANUALLY - regenerate using: python tools/generate_import_lookup.py

#include <stdafx.h>
#include <ppc/ppc_context.h>
#include <unordered_map>
#include <string>

// Forward declare all __imp__ functions
// These are defined in imports.cpp via GUEST_FUNCTION_HOOK
"""
    
    declarations = []
    for imp in imports:
        declarations.append(f"PPC_EXTERN_FUNC(__imp__{imp});")
    
    middle = """
// Build lookup table
static std::unordered_map<std::string, PPCFunc*> g_importLookup;

static void InitializeImportLookup()
{
    if (!g_importLookup.empty())
        return;

    // Register all imports
"""
    
    registrations = []
    for imp in imports:
        registrations.append(f'    g_importLookup["__imp__{imp}"] = &__imp__{imp};')
    
    footer = """
}

extern "C" PPCFunc* GetImportFunctionByName(const char* name)
{
    InitializeImportLookup();
    
    auto it = g_importLookup.find(name);
    if (it != g_importLookup.end())
        return it->second;
    
    return nullptr;
}
"""
    
    # Write the file
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(header)
        f.write('\n'.join(declarations))
        f.write('\n')
        f.write(middle)
        f.write('\n'.join(registrations))
        f.write('\n')
        f.write(footer)
    
    print(f"Generated {output_path} with {len(imports)} imports")

def main():
    # Paths
    repo_root = Path(__file__).parent.parent
    kernel_dir = repo_root / "Mw05Recomp" / "kernel"
    output_cpp = repo_root / "Mw05Recomp" / "kernel" / "import_lookup.cpp"

    # Scan all .cpp files in kernel directory (recursively)
    all_imports = set()

    for cpp_file in kernel_dir.rglob("*.cpp"):
        if cpp_file.name == "import_lookup.cpp":
            continue  # Skip the generated file

        print(f"Parsing {cpp_file}...")
        imports = extract_imports(cpp_file)
        if imports:
            print(f"  Found {len(imports)} unique __imp__ functions")
            all_imports.update(imports)

    print(f"\nTotal unique __imp__ functions: {len(all_imports)}")

    # Generate lookup table
    generate_lookup_cpp(sorted(all_imports), output_cpp)

    print("Done!")
    return 0

if __name__ == "__main__":
    sys.exit(main())

