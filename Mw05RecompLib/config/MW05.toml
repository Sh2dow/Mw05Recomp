## Need for Speed: Most Wanted (2005) â€“ Xbox 360
## XenonRecomp title profile (config) for static recompilation
## MINIMAL VERSION - Following UnleashedRecomp's approach

[main]
# XEX input/output paths are relative to this config file location
file_path = "../private/default.xex"
# Optional patch file (.xexp) if present
# patch_file_path = "../private/default.xexp"
patched_file_path = "../private/default_patched.xex"
out_directory_path = "../ppc"
switch_table_file_path = "MW05_switch_tables.toml"

# Register allocation heuristics
# NOTE: Aggressive optimizations disabled temporarily due to trace.h dependencies
# TODO: Fix trace.h to work with aggressive optimizations, then re-enable
skip_lr = false
skip_msr = false
ctr_as_local = false
xer_as_local = false
reserved_as_local = false
cr_as_local = false
non_argument_as_local = false
non_volatile_as_local = false

# Prolog/epilog helpers (MW'05 addresses)
restgprlr_14_address = 0x826BDD80
savegprlr_14_address = 0x826BDD30
restfpr_14_address   = 0x826BED3C
savefpr_14_address   = 0x826BECF0
restvmx_14_address   = 0x826BEA58
savevmx_14_address   = 0x826BE7C0
restvmx_64_address   = 0x826BEAEC
savevmx_64_address   = 0x826BE854

# longjmp_address = 0x00000000
# setjmp_address = 0x00000000

# These functions do not exist in .pdata and do
# not analyze properly due to having jump tables
# NOTE: This list should be populated from actual recompiler errors
# Currently empty - let the recompiler handle everything automatically
functions = [
    { address = 0x8215CB08, size = 0x290 }, # allocate memory
    { address = 0x8215C790, size = 0xA8 },  # find free pool slot (returns 64-bit value in r3:r4)
    { address = 0x8215C838, size = 0x50 },  # initialize pool slot
    { address = 0x821BB4D0, size = 0x90 },  # audio initialization
    { address = 0x8262FA08, size = 0xAC },  # set thread affinity
    { address = 0x826B96B0, size = 0x58 },  # set thread name
    # DISABLED - Causes crashes, need to investigate which one
    # { address = 0x82441CF0, size = 0x168 }, # main loop
    # { address = 0x8261A5E8, size = 0x1EC }, # create worker threads
    { address = 0x823C8420, size = 0x90 }   # work queue processing - TEST THIS FIRST
]

# Invalid instructions (if any are discovered during testing)
# invalid_instructions = [
#     { data = 0x00000000, size = 4 }, # Padding
# ]

# NOTE: The OS calls the main thread entry function at 0x8262E9A8 (the 'start' function in IDA)
# There are two instructions at 0x8262E9A0 and 0x8262E9A4 that are NOT part of the start function
# These are likely unreachable code or part of a different function
# The function mapping will have both 0x8262E9A0 (sub_8262E9A0) and 0x8262E9A8 (_xstart) - this is CORRECT
# The OS only calls 0x8262E9A8, so we only need hooks at that address and beyond

# Mid-ASM hooks for tracing main thread initialization
# Hook at the actual entry point (0x8262E9A8) where the OS calls the function
[[midasm_hook]]
name = "MainThreadEntryTrace"
address = 0x8262E9A8
registers = ["r3", "r4", "r5"]

[[midasm_hook]]
name = "Init1_sub_82630068"
address = 0x82630068
registers = []

[[midasm_hook]]
name = "Init2_sub_8262FDA8"
address = 0x8262FDA8
registers = ["r3"]

[[midasm_hook]]
name = "Init3_sub_826BE558"
address = 0x826BE558
registers = []

[[midasm_hook]]
name = "Init4_sub_8262FD30"
address = 0x8262FD30
registers = ["r3"]

[[midasm_hook]]
name = "Init5_sub_8262FC50"
address = 0x8262FC50
registers = ["r3"]

[[midasm_hook]]
name = "Init6_sub_8262E7F8"
address = 0x8262E7F8
registers = ["r3"]

[[midasm_hook]]
name = "Init7_sub_826BDA60"
address = 0x826BDA60
registers = []

# CRITICAL FIX: sub_826BD8D0 is marked as __noreturn in IDA, but it CAN return when a3=1
# Init7 calls sub_826BD8D0(0, 0, 1), so it WILL return
# We need to override the __noreturn annotation to prevent the compiler from optimizing away
# the code after Init7 (which includes the main loop call to sub_82441E80)
[[functions]]
address = 0x826BD8D0
name = "sub_826BD8D0"
force_return = true  # Override IDA's __noreturn annotation

[[midasm_hook]]
name = "Init8_sub_8262FB78"
address = 0x8262FB78
registers = []

# main thread entry (calls main loop)
[[midasm_hook]]
name = "MainThreadWrapper_sub_82441E80"
address = 0x82441E80
registers = ["r3", "r4", "r5"]

# Hook at the flag check in the main loop
[[midasm_hook]]
name = "MainLoopFlagCheck"
address = 0x82441D38
registers = ["r9", "r27"]

# Hooks INSIDE the wrapper function to trace execution
[[midasm_hook]]
name = "Wrapper_AfterAlloc"
address = 0x82441EA8
registers = ["r3"]

[[midasm_hook]]
name = "Wrapper_BeforeCall_sub_8261A5E8"
address = 0x82441EE0
registers = []

[[midasm_hook]]
name = "Wrapper_AfterCall_sub_8261A5E8"
address = 0x82441EE8
registers = []

[[midasm_hook]]
name = "Wrapper_BeforeMainLoopCall"
address = 0x82441F34
registers = []

# Hook in the main loop to test loader system
[[midasm_hook]]
name = "MainLoopLoaderTest"
address = 0x82441D00
registers = []

# Allocation function sub_8215CB08 is recompiled normally
# It will be overridden in C++ using PPC_FUNC_IMPL + PPC_FUNC pattern
#
# NOTE (2025-10-31): Worker thread function 0x828508A8 uses GUEST_FUNCTION_HOOK instead of midasm_hook
# midasm_hook doesn't work because it generates a stub that the linker can't find
# GUEST_FUNCTION_HOOK properly overrides the function in the lookup table
