#!/usr/bin/env python3
"""
Redirect indirect-call misses to the nearest function start (from IDA HTML).

For each address seen as an indirect-miss in mw05_debug.log:
  - Find the next function start in NfsMWEurope.xex.html (IDA export).
  - If the corresponding sub_XXXXXXXX symbol exists in recompiled sources
    (Mw05RecompLib/ppc) or app PPC hooks (Mw05Recomp), register a mapping
    miss_addr -> that host function.
  - Otherwise, emit a tiny no-op stub at miss_addr to unblock boot.

Outputs: Mw05Recomp/ppc_indirect_redirects.gen.cpp
"""

import argparse
import re
from bisect import bisect_left
from pathlib import Path


def parse_html_functions(html_path: Path) -> list[int]:
    # Stream parse to avoid loading full 1GB into memory
    rx_anchor = re.compile(r'(?:id|name)\s*=\s*["\']sub_([0-9A-Fa-f]{6,8})["\']')
    rx_label  = re.compile(r">\s*sub_([0-9A-Fa-f]{6,8})\s*[:( ]")
    addrs = set()
    with html_path.open('r', encoding='utf-8', errors='ignore') as f:
        for line in f:
            for m in rx_anchor.finditer(line):
                addrs.add(int(m.group(1), 16))
            for m in rx_label.finditer(line):
                addrs.add(int(m.group(1), 16))
    return sorted(addrs)


def parse_indirect_misses(log_path: Path) -> list[int]:
    rx = re.compile(r"indirect-miss\] target=0x([0-9A-Fa-f]{8})")
    s = set()
    with log_path.open('r', encoding='utf-8', errors='ignore') as f:
        for line in f:
            m = rx.search(line)
            if m:
                s.add(int(m.group(1), 16))
    return sorted(s)

def parse_misses_file(path: Path) -> list[int]:
    try:
        lines = path.read_text(encoding='utf-8', errors='ignore').splitlines()
    except FileNotFoundError:
        return []
    out = []
    for l in lines:
        l = l.strip()
        if not l or l.startswith('#'):
            continue
        try:
            out.append(int(l, 16))
        except ValueError:
            pass
    return sorted(set(out))


def scan_codegen_symbols(ppc_root: Path) -> set[int]:
    rx = re.compile(r"\bsub_([0-9A-Fa-f]{8})\b")
    out = set()
    for f in ppc_root.glob('ppc_recomp.*.cpp'):
        txt = f.read_text(encoding='utf-8', errors='ignore')
        out |= {int(m.group(1), 16) for m in rx.finditer(txt)}
    return out


def scan_app_hooks(app_root: Path) -> set[int]:
    rx = re.compile(r"PPC_FUNC\s*\(\s*sub_([0-9A-Fa-f]{8})\s*\)")
    out = set()
    for f in app_root.rglob('*.cpp'):
        txt = f.read_text(encoding='utf-8', errors='ignore')
        out |= {int(m.group(1), 16) for m in rx.finditer(txt)}
    return out


def emit_cpp(redirects: dict[int, int], stubs: list[int]) -> str:
    lines = []
    lines.append('// Auto-generated by tools/gen_indirect_redirects.py; DO NOT EDIT')
    lines.append('#include <kernel/memory.h>')
    lines.append('#include <cpu/ppc_context.h>')
    lines.append('')
    # Forward decls for redirect targets (C++ linkage)
    for target in sorted(set(redirects.values())):
        lines.append(f'void sub_{target:08X}(PPCContext& __restrict, uint8_t*);')
    lines.append('')
    # Stubs for unresolvable
    for a in stubs:
        lines.append(f'void sub_{a:08X}(PPCContext& __restrict, uint8_t*) {{}}')
    lines.append('')
    lines.append('static void RegisterIndirectRedirects() {')
    for miss, tgt in sorted(redirects.items()):
        lines.append(f'    g_memory.InsertFunction(0x{miss:08X}, sub_{tgt:08X});')
    for a in stubs:
        lines.append(f'    g_memory.InsertFunction(0x{a:08X}, sub_{a:08X});')
    lines.append('}')
    lines.append('')
    lines.append('#if defined(_MSC_VER)')
    lines.append('#  pragma section(".CRT$XCU",read)')
    lines.append('    static void __cdecl ppc_indirect_redirects_ctor();')
    lines.append('    __declspec(allocate(".CRT$XCU")) void (*ppc_indirect_redirects_ctor_)(void) = ppc_indirect_redirects_ctor;')
    lines.append('    static void __cdecl ppc_indirect_redirects_ctor() { RegisterIndirectRedirects(); }')
    lines.append('#else')
    lines.append('    __attribute__((constructor)) static void ppc_indirect_redirects_ctor() { RegisterIndirectRedirects(); }')
    lines.append('#endif')
    lines.append('')
    # Also expose an explicit installer we can call after memory init.
    lines.append('extern "C" void MwInstallGeneratedIndirectRedirects() { RegisterIndirectRedirects(); }')
    lines.append('')
    return "\n".join(lines) + "\n"


def main() -> int:
    ap = argparse.ArgumentParser(description='Generate indirect redirect mappings using IDA HTML')
    ap.add_argument('--log', type=Path, default=Path('mw05_debug.log'))
    ap.add_argument('--html', type=Path, default=Path('NfsMWEurope.xex.html'))
    ap.add_argument('--misses', type=Path, default=None)
    ap.add_argument('--ppc-root', type=Path, default=Path('Mw05RecompLib/ppc'))
    ap.add_argument('--app-root', type=Path, default=Path('Mw05Recomp'))
    ap.add_argument('--out-cpp', type=Path, default=Path('ppc_indirect_redirects.gen.cpp'))
    args = ap.parse_args()

    # Always emit a TU so Ninja's OUTPUT exists even on first configure.
    if (args.misses is None and not args.log.exists()) or not args.html.exists():
        args.out_cpp.parent.mkdir(parents=True, exist_ok=True)
        args.out_cpp.write_text('// No inputs yet; empty redirects/stubs.\n'
                                'extern "C" void MwInstallGeneratedIndirectRedirects(){}\n',
                                encoding='utf-8')
        print('Missing inputs; emitted empty redirects TU')
        return 0

    misses = parse_misses_file(args.misses) if args.misses is not None else parse_indirect_misses(args.log)
    starts = parse_html_functions(args.html)
    codegen = scan_codegen_symbols(args.ppc_root)
    hooks = scan_app_hooks(args.app_root)

    redirects: dict[int, int] = {}
    stubs: list[int] = []
    for m in misses:
        i = bisect_left(starts, m)
        target = None
        if i < len(starts):
            target = starts[i]
        # Only redirect if we actually have the symbol compiled (codegen or app)
        if target is not None and (target in codegen or target in hooks):
            redirects[m] = target
        else:
            stubs.append(m)

    args.out_cpp.parent.mkdir(parents=True, exist_ok=True)
    args.out_cpp.write_text(emit_cpp(redirects, stubs), encoding='utf-8')
    print(f'Wrote {args.out_cpp} with {len(redirects)} redirects and {len(stubs)} stubs')
    return 0


if __name__ == '__main__':
    raise SystemExit(main())
