#!/usr/bin/env python3
"""
Generate stubs for indirect-call misses seen in mw05_debug.log.

Parses the log, filters out addresses that already exist as recompiled
functions or app-side PPC_FUNCs, and emits Mw05Recomp/ppc_indirect_stubs.gen.cpp
with tiny stubs that return (and optionally log once). This unblocks boot by
filling callback tables, at the cost of functionality, so keep it behind an
opt-in CMake option.
"""

import argparse
import re
from pathlib import Path


def parse_indirect_misses(log: Path) -> set[int]:
    rx = re.compile(r"indirect-miss\] target=0x([0-9A-Fa-f]{8})")
    misses = set()
    for line in log.read_text(encoding="utf-8", errors="ignore").splitlines():
        m = rx.search(line)
        if m:
            misses.add(int(m.group(1), 16))
    return misses


def scan_codegen_functions(ppc_root: Path) -> set[int]:
    rx = re.compile(r"\bsub_([0-9A-Fa-f]{8})\b")
    out = set()
    for f in ppc_root.glob("ppc_recomp.*.cpp"):
        txt = f.read_text(encoding="utf-8", errors="ignore")
        out |= {int(m.group(1), 16) for m in rx.finditer(txt)}
    return out


def scan_app_ppc_funcs(app_root: Path) -> set[int]:
    rx = re.compile(r"PPC_FUNC\s*\(\s*sub_([0-9A-Fa-f]{8})\s*\)")
    out = set()
    for f in app_root.rglob("*.cpp"):
        txt = f.read_text(encoding="utf-8", errors="ignore")
        out |= {int(m.group(1), 16) for m in rx.finditer(txt)}
    return out


def emit_cpp(addrs: list[int]) -> str:
    lines = []
    lines.append("// Auto-generated by tools/gen_indirect_stubs.py; DO NOT EDIT")
    lines.append("#include <kernel/memory.h>")
    lines.append("#include <cpu/ppc_context.h>")
    lines.append("#include <cstdio>")
    lines.append("")
    for a in addrs:
        name = f"sub_{a:08X}"
        lines.append(f"void {name}(PPCContext& __restrict, uint8_t*) {{}}")
    lines.append("")
    lines.append("static void RegisterIndirectStubs() {")
    for a in addrs:
        name = f"sub_{a:08X}"
        lines.append(f"    g_memory.InsertFunction(0x{a:08X}, {name});")
    lines.append("}")
    lines.append("")
    lines.append("#if defined(_MSC_VER)")
    lines.append("#  pragma section(\".CRT$XCU\",read)")
    lines.append("    static void __cdecl ppc_indirect_ctor();")
    lines.append("    __declspec(allocate(\".CRT$XCU\")) void (*ppc_indirect_ctor_)(void) = ppc_indirect_ctor;")
    lines.append("    static void __cdecl ppc_indirect_ctor() { RegisterIndirectStubs(); }")
    lines.append("#else")
    lines.append("    __attribute__((constructor)) static void ppc_indirect_ctor() { RegisterIndirectStubs(); }")
    lines.append("#endif")
    lines.append("")
    return "\n".join(lines) + "\n"


def main() -> int:
    ap = argparse.ArgumentParser(description="Generate PPC stubs for indirect misses")
    ap.add_argument("--log", type=Path, default=Path("mw05_debug.log"))
    ap.add_argument("--ppc-root", type=Path, default=Path("Mw05RecompLib/ppc"))
    ap.add_argument("--app-root", type=Path, default=Path("Mw05Recomp"))
    ap.add_argument("--out-cpp", type=Path, default=Path("Mw05Recomp/ppc_indirect_stubs.gen.cpp"))
    args = ap.parse_args()

    if not args.log.exists():
        print(f"Log not found: {args.log}")
        return 0

    misses = parse_indirect_misses(args.log)
    have_codegen = scan_codegen_functions(args.ppc_root)
    have_app = scan_app_ppc_funcs(args.app_root)

    addrs = sorted(a for a in misses if a not in have_codegen and a not in have_app)
    args.out_cpp.parent.mkdir(parents=True, exist_ok=True)
    args.out_cpp.write_text(emit_cpp(addrs), encoding="utf-8")
    print(f"Wrote {args.out_cpp} with {len(addrs)} stub(s)")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
